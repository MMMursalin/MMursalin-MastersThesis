{"kind":"Notebook","sha256":"a12d5b09adb49ac96d6fbdf8148daaef0fbea19302244f74a6552bd95e0db558","slug":"finalpotentialplots","location":"/Figures_Draft3/Fig2_PotentialPlot/FinalPotentialPlots.ipynb","dependencies":[],"frontmatter":{"keywords":[],"exports":[{"format":"ipynb","filename":"FinalPotentialPlots.ipynb","url":"/FinalPotentialPlots-da28902c36503b131896039f29c6853f.ipynb"}]},"mdast":{"type":"root","children":[{"type":"block","children":[{"type":"code","lang":"python","executable":true,"value":"import numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nfrom scipy.optimize import minimize_scalar\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\n\n# Increase the font size and bold the text for titles and axis labels globally\nplt.rcParams.update({\n    'axes.titlesize': 15,  # Increase the font size of the title\n    'axes.titleweight': 'bold',  # Bold the title font\n    'axes.labelsize': 15,  # Increase the font size of the axis labels\n    'axes.labelweight': 'bold',  # Bold the axis label font\n    'grid.alpha': 0.5,  # Set grid line transparency\n    'legend.fontsize': 12  # Set the legend font size\n})\n# Define the symlog function\ndef symlog(x, linthresh=1):\n    is_negative = x < 0\n    abs_x = np.abs(x)\n    abs_x = np.where(abs_x < linthresh, 0, np.log10(abs_x))\n    return np.where(is_negative, -abs_x, abs_x)\n\n# Define the potential function in HOOMD Blue units\ndef potential(x, u, qi_qj_ratio, k, s):\n    # The potential function, adjusted for the provided units\n    # qi_qj_ratio is unitless\n    # u is in kJ/mol, x in nm, k in 1/nm, s in nm\n    screened_coulomb = (qi_qj_ratio * np.exp(-k * x)) / x\n    lennard_jones = 4 * u * ((s / x)**12 - (s / x)**6)\n    return screened_coulomb + lennard_jones\n\n# Function to find the minimum x of the potential\ndef find_potential_minimum(u, qi_qj_ratio, k, s):\n    # Minimize the potential function to find the minimum x value\n    result = minimize_scalar(potential, bounds=(0.1, 5), args=(u, qi_qj_ratio, k, s), method='bounded')\n    return result.x  # Return the seperation at which the potential is minimum\n\n# Set up the figure for animation\nfig, ax = plt.subplots(figsize=(10, 8))\nS_values = np.linspace(0.1, 25, 100)  # S in nm\nqi_qj_ratios = np.array([-1E6, -1E5, -1E4, -1E3, -100, -50, -10, -5, -1, -0.5, 0, 0.5, 1, 5, 10, 50, 100, 1E3, 1E4, 1E5, 1E6])  # qi/qj ratios\nS, Q = np.meshgrid(S_values, qi_qj_ratios, indexing='ij')\n\n# Function to update the plot for each frame when animating k\ndef animate_k(frame):\n    u = 1\n    k = 0.1 + (15 - 0.01) * (frame / 99)  # Vary k from 0.1 to 1.5 over 100 frames\n    # Calculate XMin - S\n    X_min_diff = np.array([[find_potential_minimum(u, ratio, k, s) - s for ratio in qi_qj_ratios] for s in S_values])\n    ax.clear()\n    # Plot the difference in x values\n    contour = ax.contourf(S, symlog(Q), X_min_diff, levels=100, cmap='PiYG')\n    ax.set_xlabel('Sum Radii $r_i+r_j$ [nm]')  # Updated label\n    ax.set_ylabel('Log Charge product $q_i*q_j$ [Elem. Charge$^2$]')  # Updated label\n    ax.set_title(f'Favored Particle Spacing, Varying Screening Length=1/{k:.2f} [nm]')\n    return contour,\n\n# Function to update the plot for each frame when animating u\ndef animate_u(frame):\n    k = 1.28\n    u = 0.1 + (100 - 0.01) * (frame / 99 )  # Vary u from 0.1 to 10.0 over 100 frames\n    # Calculate XMin - S\n    X_min_diff = np.array([[find_potential_minimum(u, ratio, k, s) - s for ratio in qi_qj_ratios] for s in S_values])\n    ax.clear()\n    # Plot the difference in x values\n    contour = ax.contourf(S, symlog(Q), X_min_diff, levels=100, cmap='PiYG')\n    ax.set_xlabel('Sum Radii $r_i+r_j$ [nm]')  # Updated label\n    ax.set_ylabel('Log Charge product $q_i*q_j$ [Elem. Charge$^2$]')  # Updated label\n    ax.set_title(f'Favored Particle Spacing, Varying $\\epsilon$ = {u:.2f} [kJ/mol]')  # Updated title\n    return contour,\n\n# Create the animation\n#ani_k = FuncAnimation(fig, animate_k, frames=25, interval=100)\n\n# Save the animation as a gif\n#ani_k.save('varying_k_Norm.gif', writer='pillow', dpi=100)\n\n# Create the animation\n#ani_u = FuncAnimation(fig, animate_u, frames=25, interval=100)\n\n# Save the animation as a gif\n#ani_u.save('varying_u_Norm.gif', writer='pillow', dpi=100)\n\n# Create a separate legend color bar\nmin_diff = -1  # minimum possible value of (XMin - S)\nmax_diff = 1  # maximum possible value of (XMin - S)\n\n# Create a figure for the color bar\nfig_colorbar, ax_colorbar = plt.subplots(figsize=(6, 1))\nfig_colorbar.subplots_adjust(bottom=0.5)\n\n# Set the colormap and normalize to the range of (XMin - S) values\ncmap_colorbar = mpl.cm.PiYG\nnorm_colorbar = mpl.colors.Normalize(vmin=min_diff, vmax=max_diff)\n\ncb_colorbar = mpl.colorbar.ColorbarBase(ax_colorbar, cmap=cmap_colorbar, norm=norm_colorbar, orientation='horizontal')\ncb_colorbar.set_label('Separation of Particles at the Energy Minimum [nm]')\n\n# Save the colorbar figure as an image\nfig_colorbar.savefig('colorbar.png', dpi=300)\n\nplt.show()\n","key":"Ykwg6CqTsw"},{"type":"output","id":"jtVxBuLrDWwnOB3uZ_lzl","data":[{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"d4a24a31b0235d98c553126f6921d53c","path":"/d4a24a31b0235d98c553126f6921d53c.png"},"text/plain":{"content":"<Figure size 1000x800 with 1 Axes>","content_type":"text/plain"}}},{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"c504abdacdf42939a21b3ecec3e5bb6a","path":"/c504abdacdf42939a21b3ecec3e5bb6a.png"},"text/plain":{"content":"<Figure size 600x100 with 1 Axes>","content_type":"text/plain"}}}],"key":"UtAeqxsbYW"}],"data":{"type":"notebook-code"},"key":"HgO2M4IRVk"},{"type":"block","children":[{"type":"code","lang":"python","executable":true,"value":"import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.optimize import minimize_scalar\n\n# Increase the font size and bold the text for titles and axis labels globally\nplt.rcParams.update({\n    'axes.titlesize': 15,  # Increase the font size of the title\n    'axes.titleweight': 'bold',  # Bold the title font\n    'axes.labelsize': 15,  # Increase the font size of the axis labels\n    'axes.labelweight': 'bold',  # Bold the axis label font\n    'grid.alpha': 0.5,  # Set grid line transparency\n    'legend.fontsize': 12  # Set the legend font size\n})\n\ndef potential(x, u, qi_qj_ratio, k, s):\n    screened_coulomb = (qi_qj_ratio * np.exp(-k * x)) / x\n    lennard_jones = 4 * u * ((s / x)**12 - (s / x)**6)\n    return screened_coulomb + lennard_jones\n\ndef find_potential_minimum(u, qi_qj_ratio, k, s):\n    result = minimize_scalar(potential, bounds=(0.1, 5), args=(u, qi_qj_ratio, k, s), method='bounded')\n    return result.x\n\ndef generate_corrected_plots(u_values, k_values, S_values, qi_qj_ratios):\n    fig_eps, axs_eps = plt.subplots(1, 3, figsize=(18, 6))\n    fig_eps.suptitle('Varying ε', fontsize=16, fontweight='bold')\n    fig_k, axs_k = plt.subplots(1, 3, figsize=(18, 6))\n    fig_k.suptitle('Varying k', fontsize=16, fontweight='bold')\n    S_mesh, Q_mesh = np.meshgrid(S_values, qi_qj_ratios)\n    for ax, u in zip(axs_eps, u_values):\n        X_min_diff = np.array([[find_potential_minimum(u, Q_mesh[i, j], 1.0, S_mesh[i, j]) - S_mesh[i, j] for j in range(len(S_values))] for i in range(len(qi_qj_ratios))])\n        ax.contourf(S_mesh, Q_mesh, X_min_diff, levels=100, cmap='PiYG')\n        ax.set_title(f'ε = {u} [kJ/mol]')\n        ax.set_xlabel('Sum Radii $r_i+r_j$ [nm]')\n        ax.set_ylabel('Charge product $q_i*q_j$')\n    for ax, k in zip(axs_k, k_values):\n        X_min_diff = np.array([[find_potential_minimum(1.0, Q_mesh[i, j], k, S_mesh[i, j]) - S_mesh[i, j] for j in range(len(S_values))] for i in range(len(qi_qj_ratios))])\n        ax.contourf(S_mesh, Q_mesh, X_min_diff, levels=100, cmap='PiYG')\n        ax.set_title(f'k = {k} [1/nm]')\n        ax.set_xlabel('Sum Radii $r_i+r_j$ [nm]')\n        ax.set_ylabel('Charge product $q_i*q_j$')\n        fig_eps.savefig('varying_epsilon.png', format='png'); fig_k.savefig('varying_k.png', format='png')\n    plt.show()\n\nS_values = np.linspace(0.1, 2.5, 100)\nqi_qj_ratios = np.array([-1E6, -1E5, -1E4, -1E3, -100, -50, -10, -5, -1, -0.5, 0, 0.5, 1, 5, 10, 50, 100, 1E3, 1E4, 1E5, 1E6])\nu_values = [0.1, 1, 10.0]\nk_values = [0.128, 1.28, 12.8]\n\ngenerate_corrected_plots(u_values, k_values, S_values, qi_qj_ratios)\n\n","key":"U3FgDdcTfW"},{"type":"output","id":"_LmpfUL98kabCkRg5g7tv","data":[{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"581d516b5fd63de5e104c7f40337bb33","path":"/581d516b5fd63de5e104c7f40337bb33.png"},"text/plain":{"content":"<Figure size 1800x600 with 3 Axes>","content_type":"text/plain"}}},{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"2a27aeda4c8a7855703faf13dfb85f2a","path":"/2a27aeda4c8a7855703faf13dfb85f2a.png"},"text/plain":{"content":"<Figure size 1800x600 with 3 Axes>","content_type":"text/plain"}}}],"key":"qLkn4f2E6T"}],"data":{"type":"notebook-code"},"key":"IKx3sDZsKA"},{"type":"block","children":[{"type":"code","lang":"python","executable":true,"value":"# Increase the font size and bold the text for titles and axis labels globally\nplt.rcParams.update({\n    'axes.titlesize': 14,  # Increase the font size of the title\n    'axes.titleweight': 'bold',  # Bold the title font\n    'axes.labelsize': 12,  # Increase the font size of the axis labels\n    'axes.labelweight': 'bold',  # Bold the axis label font\n    'grid.alpha': 0.5,  # Set grid line transparency\n    'legend.fontsize': 10  # Set the legend font size\n})\n\nplt.colorbar(plt.cm.ScalarMappable(cmap='PiYG'), cax=plt.subplots(figsize=(6, 1))[1], orientation='horizontal').set_label('Separation of Particles at the Energy Minimum [nm]'); plt.savefig('colorbar.png', format='png')\n","key":"PlQ06amHTL"},{"type":"output","id":"B9rxiQLEUIX0MaPBS4bTy","data":[{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"e592c4848acc1533e416638634a09aab","path":"/e592c4848acc1533e416638634a09aab.png"},"text/plain":{"content":"<Figure size 600x100 with 1 Axes>","content_type":"text/plain"}}}],"key":"pPeDVxEawP"}],"data":{"type":"notebook-code"},"key":"RELP5gtqBK"}],"key":"HbIUQVYT8a"},"references":{"cite":{"order":[],"data":{}}}}